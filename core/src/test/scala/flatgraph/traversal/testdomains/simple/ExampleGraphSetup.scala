package flatgraph.traversal.testdomains.simple

import flatgraph.help.Table.AvailableWidthProvider
import flatgraph.{DiffGraphApplier, DiffGraphBuilder, FreeSchema, GNode, GenericDNode, Graph, SinglePropertyKey, TestSchema}
import flatgraph.help.{Doc, DocSearchPackages, Traversal, TraversalHelp, TraversalSource}
import flatgraph.traversal.testdomains.simple.SimpleDomain.Thing
import flatgraph.traversal.Language.*

/* simple example graph:
 * L3 <- L2 <- L1 <- Center -> R1 -> R2 -> R3 -> R4 -> R5
 * */
trait ExampleGraphSetup {
  import ExampleGraphSetup.Properties.*
  val nonExistingLabel = "this label does not exist"

  val graph  = SimpleDomain.newGraph
  val l3     = addNode()
  val l2     = addNode()
  val l1     = addNode()
  val center = addNode()
  val r1     = addNode()
  val r2     = addNode()
  val r3     = addNode()
  val r4     = addNode()
  val r5     = addNode()

  val diff = new DiffGraphBuilder(graph.schema)
  // TODO reimplement arrow synax from odb
  // center --- Connection.Label --> l1
  // l1 --- Connection.Label --> l2
  // l2 --- Connection.Label --> l3
  // center --- Connection.Label --> r1
  // r1 --- (Connection.Label, Connection.Properties.Distance.of(10)) --> r2
  // r2 --- (Connection.Label, Connection.Properties.Distance.of(10)) --> r3
  // r3 --- (Connection.Label, Connection.Properties.Distance.of(13)) --> r4
  // r4 --- (Connection.Label, Connection.Properties.Distance.of(14)) --> r5
  diff
    ._addEdge(center, l1, 0)
    ._addEdge(l1, l2, 0)
    ._addEdge(l2, l3, 0)
    ._addEdge(center, r1, 0)
    ._addEdge(r1, r2, 0)
    ._addEdge(r2, r3, 0)
    ._addEdge(r3, r4, 0)
    ._addEdge(r4, r5, 0)
    .setNodeProperty(l3, Name.name, "L3")
    .setNodeProperty(l2, Name.name, "L2")
    .setNodeProperty(l1, Name.name, "L1")
    .setNodeProperty(center, Name.name, "Center")
    .setNodeProperty(r1, Name.name, "R1")
    .setNodeProperty(r2, Name.name, "R2")
    .setNodeProperty(r3, Name.name, "R3")
    .setNodeProperty(r4, Name.name, "R4")
    .setNodeProperty(r5, Name.name, "R5")
  DiffGraphApplier.applyDiff(graph, diff)

  def addNode(): GNode = {
    val newNode = new GenericDNode(0)
    DiffGraphApplier.applyDiff(graph, DiffGraphBuilder(graph.schema).addNode(newNode))
    newNode.storedRef.get // that reference is set by DiffGraphApplier
  }
}
object ExampleGraphSetup {
  // property keys etc are normally generated by DomainClassesGenerator for a given schema
  object Properties {
    val Name        = SinglePropertyKey(kind = 0, name = "name", default = "<empty>")
    val NonExisting = SinglePropertyKey(kind = 10, name = "this property key does not exist", default = "default value 0")
  }
}

object SimpleDomain {
  class Thing(graph: Graph, nodeKind: Short, seqId: Int) extends GNode(graph, nodeKind, seqId) {
    def name: String = ???
  }
  object Thing {
    val Label = "Thing"
  }

  object Connection {
    val Label = "Connection"
  }

  val defaultDocSearchPackage: DocSearchPackages = DocSearchPackages(getClass.getPackage.getName)
  def help(using AvailableWidthProvider) =
    TraversalHelp(defaultDocSearchPackage).forTraversalSources(verbose = false)
  def helpVerbose(using AvailableWidthProvider) =
    TraversalHelp(defaultDocSearchPackage).forTraversalSources(verbose = true)

  def newGraph: Graph = {
    val edgeLabels = Array(Connection.Label)
    val schema = new FreeSchema(
      nodeLabels = Array(Thing.Label),
      edgeLabels = edgeLabels,
      propertyLabels = Array(ExampleGraphSetup.Properties.Name.name),
      propertyNamesByNodeLabel = Map.empty,
      edgePropertyPrototypes = new Array(edgeLabels.length),
      nodePropertyPrototypes = Array(Array.empty[String])
    )
    Graph(schema)
  }

  def traversal(graph: Graph) = new SimpleDomainTraversalSource(graph)
}

@TraversalSource
class SimpleDomainTraversalSource(graph: Graph) {

  @Doc(info = "all things")
  def things: Iterator[Thing] =
    graph.nodes("V0").cast[Thing]
}

/** Example for domain specific extension steps that are defined in a different package. TraversalTests verifies that the .help step finds
  * the documentation as specified in @Doc
  *
  * @param traversal
  */
@Traversal(elementType = classOf[SimpleDomain.Thing])
class SimpleDomainTraversal(val traversal: Iterator[SimpleDomain.Thing]) extends AnyVal {

  @Doc(info = "name of the Thing")
  def name: Iterator[String] = traversal.map(_.name)
}
